# npmではなくpnpmを使う理由

このリポジトリは **pnpm を前提** に設計されています。npm はサポート対象外です。

## pnpmがnpmより技術的に優れている点

このプロジェクトの運用に関係する範囲で、pnpmの優位点は以下です。

- **保存方式が効率的**: 依存パッケージを content-addressable store に一度だけ保存し、各プロジェクトはリンク参照するため、同一バージョンの重複を避けられる
- **インストールが速くなりやすい**: 既存ストアの再利用により、CIやローカルでの再インストールが軽くなる
- **依存の境界が厳密**: `node_modules` をフラットにしないため、宣言していない依存への“たまたまの参照”を早期に検知できる
- **モノレポ運用が実用的**: `pnpm --filter` で対象パッケージだけを扱えるため、大規模ワークスペースでも作業が細かく切れる
- **再現性の担保**: `pnpm-lock.yaml` と `packageManager` により、依存の解決結果とツールのバージョンを固定できる

## このリポジトリでpnpmが必須な理由

このリポジトリでは、プラグインを **独立パッケージとして運用できる設計** を前提にしています。
そのため、ワークスペースと依存解決の挙動が重要です。

- `pnpm-workspace.yaml` に `plugins/*` を含め、プラグインをワークスペースの一員として扱う
- プラグインごとの依存関係を明示させ、暗黙依存を検知できる必要がある
- `workspace:*` を使った内部パッケージ参照があり、確実なリンク解決が必要
- `pnpm --filter` や `pnpm -r` など pnpm 固有のコマンドをスクリプトで使用している

## npmを使うと起きやすい問題

- pnpm 前提のスクリプトが実行できない、または挙動が変わる
- `package-lock.json` が更新され、実際の依存グラフ（`pnpm-lock.yaml`）と不一致になる
- hoisting により依存解決が変化し、環境差分や隠れた依存が発生しやすい
- プラグイン単位での依存の境界が曖昧になり、プラグインの再配布や互換性検証に支障が出る

## 推奨手順

```bash
corepack enable
corepack prepare pnpm@9.15.4 --activate
pnpm install
```

`corepack` が利用できない場合は、pnpm を別途インストールしてから `pnpm install` を実行してください。
